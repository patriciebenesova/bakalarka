
\documentclass[a4paper,12pt]{scrreprt}
\usepackage[cp1250]{inputenc}
\usepackage[czech]{babel}
%\selectlanguage{english}
\hyphenation{oddword}
\usepackage{graphicx}
\usepackage{chngcntr}
\counterwithout{figure}{chapter}
\counterwithout{table}{chapter}
%\usepackage{hyperref}
%\usepackage[T1]{fontenc}
\usepackage[a4paper,left=30mm,right=20mm,top=25mm,bottom=25mm]{geometry}
%\newcommand\uv[1]{\quotedblbase #1\textquotedblleft}%
\usepackage{indentfirst}
\renewcommand{\sectfont}{\rmfamily}
\usepackage{cite}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\begin{titlepage}
\begin{center}
{\Large Vysoká škola ekonomická v Praze\\}
{\large Fakulta informatiky a statistiky\\
Katedra informaèních technologií\\}
\vspace{2cm}
Studijní program:  Aplikovaná informatika\\
Obor:  Informatika\\
\vspace{4cm}
{\huge Název bakaláøské práce\\}
\vspace{2cm}
BAKALÁØSKÁ PRÁCE\\
\vspace{3cm}
Student	:	Jméno a pøíjmení studenta\\
Vedoucí	:	Jméno a pøíjmení s tituly\\
Oponent	:	Jméno a pøíjmení s tituly\\
\vspace{2cm}

2016
\end{center}

\end{titlepage}

%prohlaseni----------------------------------------------------------------------
\begin{center}
\vspace*{15cm}
{\large Prohlášení\\}
\end{center}
\vspace{1cm}
Prohlašuji, e jsem bakaláøskou/diplomovou práci zpracoval(a) samostatnì a e jsem uvedl(a) všechny pouité prameny a literaturu, ze které jsem èerpal(a).

\vspace{3cm}
\begin{flushright}
 V Praze dne den. mìsíc 2016 \hspace{5cm}. . . . . . . . . . . . . . . . . . . . . . . . \\
Jméno a pøíjmení studenta
\end{flushright}

\thispagestyle{empty}
%podekovani--------------------------------------------------------------------
\begin{center}
\vspace*{18cm}
{\large Podìkování\\}
\end{center}
\vspace{1cm}
Teoreticky tato pasá ve vaši práci bıt nemusí a mùete ji smazat. Pokud byste však chtìli nìkomu podìkovat, zde je to správné místo. V podìkování mùete uvést vedoucího práce, pøípadnì konzultanta, nesmíte zde však uvést oponenta. Mezi ty, kterım dìkujete, mùete samozøejmì zaøadit i své blízké, i kdy to nebıvá zvykem. 
\thispagestyle{empty}
%abstrakt cz ---------------------
\newpage
\textbf{Abstrakt\\}
%\indent 
Obsahuje zamìøení a hlavní cíl práce, zpùsob dosaení cíle, pøínos práce (vlastní pøíspìvek k øešenému tématu) a struènì popsanou strukturu práce.\\

\textbf{Klíèová slova \\}

\indent Seznam nejvıznamnìjších odbornıch vırazù charakterizujících téma závìreèné práce.

\thispagestyle{empty}
%abstract en -------------
\newpage
\textbf{Abstract\\}

\indent Obsahuje zamìøení a hlavní cíl práce, zpùsob dosaení cíle, pøínos práce (vlastní pøíspìvek k øešenému tématu) a struènì popsanou strukturu práce.\\

\textbf{Key words \\}

\indent Seznam nejvıznamnìjších odbornıch vırazù charakterizujících téma závìreèné práce.

\thispagestyle{empty}

%obsah------------------------------------------------------------------------
\tableofcontents
\thispagestyle{empty}

%text----------------------------------------------------------------------------
\chapter{Úvod}

\section{vymezení tématu práce a dùvod vıbìru tématu}
\section{cíle práce}
\section{zpùsob/metoda dosaení cíle}
\section{pøedpoklady a omezení práce, struktura práce}
\section{vıstupy práce (pøíp. komu jsou urèeny) a oèekávané pøínosy}
\setcounter{page}{1}

\chapter{Historie}
V roce 1956 americkı matematik a logik Stephen Cole Kleene popsal deterministické koneèné automaty (DFA), které rozpoznávají formální jazyk. Jazyk rozpoznatelnı koneènım automatem se poté nazıvá regulárním jazykem, protoe se vyznaèuje \uv{pravidelností} (regularitou)\cite{1}

Na Kleeneho v roce 1968 navázal programátor, známı pøedevším díky operaènímu systému Unix, Kenneth Thomson. Publikoval èlánek \uv{Regular Expression Search Algorithm}\cite{2}, ve kterém popsal algoritmus pro vyhledávání pomocí regulárních vırazù v textu.

Thomson také implementoval Kleeneho notaci do textového editoru QED. Tuto funkci poté zabudoval i do unixového editoru ed, co pozdìji vedlo ke vzniku vyhledávacího poèítaèového programu grep.Pozdìji byly regulární vırazy zabudovány do jazyka AWT èi do pøíkazu expr pouívaném v pøíkazové øádce v unixovıch systémech.

Komplikovanìjší regulární vırazy se v 80. letech minulého století zaèaly objevovat v jazyce Perl. Vycházely pøitom z regex knihovny napsané kanadskım programátorem Henry Spencerem. Zaèaly se zde objevovat i regulární vırazy, na které nebylo moné pouít koneènı deterministickı automat, u kterého mùeme v kadém jeho stavu jasnì urèit, co automat udìlá. Byly ale moné rozpoznat nedeterministickımi koneènımi automaty (NFA), u kterıch pøevauje jistá míra nejednoznaènosti. Spencer pozdìji regulární vırazy implementoval i do skriptovacího jazyka Tcl, známé pod názvem Advance Regular Expressions (ARE).

V roce 1992 byly regulární vırazy v pùvodní podobì standardizovány v POSIX.2 standardu. Nicménì poèítaèovı programátor Philip Hazel v roce 1997 vyvynul PCRE (Perl Compatible Regular Expressions), jeho syntaxe je více flexibilní ne v POSIXu. Je vyuíván napøíklad v jazyce PHP nebo Apache HTTP Server.\cite{3}I kdy úplnı název PCRE zní \uv{Perl Compatible Regular Expressions}, PCRE a Perl mají své odlišnosti\cite{4}, které v této práci nebudou podrobnìjí popsány. 

Dnes jsou regulární vırazy podporovány v mnoha jazycích a programech jako napøíklad Java, Python, JavaScript atd.
\newpage
\chapter{Syntaxe regulárních vırazù}
\section{Definice}
Regulární vırazy nemají pøesnou definici, nicménì dají se popsat jako textové øetìzce, které slouí jako vzor pro vyhledávání ve strukturovaném nebo nestrukturovaném textu. Dalším pøípadem uití mùe bıt nahrazování èi rozdìlování textu. 

Jak ji bylo zmínìno v pøedchozí kapitole, jsou vyuívány v mnoha aplikacích a programovacích jazycích a jejich knihovnách.
\cite[s.1--3]{5} Jejich implementace není ale ve všech jazycích stejná, a proto budu v následujícím textu uvádìt odlišnosti syntaxe regulárních vırazù ve vybranıch jazycích (tzv.\uv{pøíchutì} regulárních vırazù).

Existují rùzné desktopové i webové aplikace, které umoòují rozpoznávání regulárních vırazù v rùznıch jazycích, èím umoòují ovìøení správnosti zadaného vırazu. Mezi webové aplikace patøí napøíklad:
\begin{itemize}
	\item \verb|http://regex101.com/|
	\item \verb|http://regexr.com/|
\end{itemize}
Z desktopovıch aplikací bych uvedla napøíklad \uv{The Regex Couch}, kterı lze stáhnout zde: \verb|http://weitz.de/regex-coach/|.
\section{Literály a jejich øetìzení}
Øetìzení umoòuje spojit jednotlivé znaky do skupin. Napøíklad regulárnímu vırazu: \texttt{abc} vyhoví jakıkoli øetìzec, kterı obsahuje danou skupinu na libovolném místì. Regulární vıraz tedy vyhoví napøíklad øetìzcùm:\uv{jkl\textbf{abc}jdabd}nebo \uv{\textbf{abc}ccccd}, ale nenajde shodu v øetìzci: \uv{ajbc}. 

Jak toto vyhledávání funguje vystvìtlím na následujícím pøíkladu. Mìjme ji vıše uvedenı vzor \texttt{abc} a øetìzec:\uv{kaabc}. Pøi vyhledávání se zaèíná zleva na pozici ještì pøed prvním znakem a postuje se po jednotlivıch znacích smìrem doprava. Nejprve se vezme znak \uv{k}, na kterém regulární vıraz sele, protoe první znak vzoru je \uv{a}. Proto se zaène vyhledávat od znova, tentokrát ale od pozice pøed druhım znakem a proces se opakuje. Tento proces vracení se, se nazıvá \uv{backtracking}. Druhı znak øetìzce je \uv{a}. Zde regulární vıraz uspìje. Poté ovšem sele pøi porovnávání tøetího znaku øetìzce \uv{a} s literálem \uv{b}. Opìt provede backtracking a zaène se porovnávat od pozice tìsnì pøed tøetím znakem øetìzce. Zde najde shodu. Poté pokraèuje v porovnávání ètvrtého znaku øetìzce \uv{b} se znakem \uv{b} regulárního vırazu, zde opìt najde shodu. Podobnì najde shodu i pøi znaku \uv{c}.\cite{6}

Názornì tento proces lze vidìt na obrázku 1.
\begin{figure}[h!]
	\centering
		\includegraphics[scale = 1]{backtracking.PNG}
	\caption{Backtrack}
	\label{fig:obr1}
\end{figure}


Pøi pouití regulárního vırazu v tomto tvaru musíme brát v úvahu, e lze pouívat pouze ASCII znaky a regulární vıraz najde pouze první shodu v øetìzci. Dále regulární vırazy jsou \uv{case-sensitive}, co znamená, e vıše uvedenı regulární vıraz nerozezná napøíklad øetezec \uv{Abc}.\cite[s.26]{5}

Jako øešení vıše uvedenıch omezení slouí tzv. \uv{modifikátory}. Jaké èásti regulárních vırazù, popø. tøíd je potøeba v daném jazyce, pro pouití vzoru v módu \uv{case-insensitive} neboli ignorování velkıch a malıch písmen, lze vidìt  v tabulce 1.

\begin{table}[h]
\centering
\caption[Case insensitive (viz. \cite{5})]{Case insesitive}
\label{tab: tab1}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|l|}{Case insensitive}                                                                  \\ \hline
Java       & \begin{tabular}[c]{@{}l@{}}Pattern.CASE\_INSENSITIVE\\ nebo (?i)\end{tabular}            \\ \hline
Perl       & \verb|/i |                                                                               \\ \hline
AWK        & \begin{tabular}[c]{@{}l@{}}IGNORECASE = 0\\ (zajistí zapnutí módu globálnì v gawk)\end{tabular} \\ \hline
Javascript & \verb|/i |                                                                                \\ \hline
PCRE       & \verb|/i |      \\ \hline                                                                                  
\end{tabular}
\end{table}




\section{Metaznaky}
Kromì alfanumerickıch znakù se v regulárních vırazech pouívají tzv. metaznaky. Metaznak má v regulárním vırazu speciální funkci a je jich celkem 12: \verb|$()*+.?[\^{| \textbf{$\vert$}. Regulární vıraz tyto metaznaky nerozpozná jako obyèejné alfanumerické znaky. Pro rozpoznání nìkterého z vıše uvedenıch znakù jako takovıch je tøeba potlaèit jejich funkci pouitím zpìtného lomítka \textbf{\textbackslash} (tzv. escape). Znaky \verb|]| a \verb|}| není potøeba zapisovat se zpìtnım lomítkem, vıjimkou jsou pouze pøípady, kdy následují za \verb|[| nebo \verb|{| bez zpìtného lomítka. Jazyk AWK navíc vyaduje i escapování dvojitıch uvozovek \verb|\"| a lomítka \verb|\/|. Nìkteré verze AWK navíc dovolují pouít znaky \verb|*+?| bez zpìtného lomítka jako literály v pøípadì, e se nevyskytují na místì kvantifikátoru (viz. kapitola Kvantifikátory). Pøi escapování jiného znaku ne vıše uvedené, vetšina jazykù bere následující znak jako literál a ne jako metaznak. 

Metaznak \uv{.} (teèka) zachytí jakıkoliv znak kromì znaku konce øádky. Toto pravidlo platí v jazycích Java, Javascript, Perl,PCRE,.NET nebo Python. Nicménì konec øádky lze tìèkou zachytit pouitím \uv{single line} módu (\uv{dot all} módu). Tuto monost ovšem nelze vyuít v jazyce Javascript. \cite[s.34--36]{5} Jazyk AWK podporuje mód multiline automaticky.
Jak danı mód zapnout, lze zjistit z tabulky 2.

\begin{table}[h]
\centering
\caption[Single line (viz. \cite{5})]{Single line neboli Dot all mód}
\label{tab: tab2}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|l|}{Dot all}                                                   \\ \hline
Java       & Pattern.DOTALL                                                     \\ \hline
Perl       & \verb|/s |                                                               \\ \hline
AWK        & \begin{tabular}[c]{@{}l@{}}ji implicitnì\\ nastaveno\end{tabular} \\ \hline
Javascript & nepodporuje                                                        \\ \hline
PCRE       & \verb|/s |                                                                 \\ \hline
\end{tabular}
\end{table} 

Dalšími metaznaky jsou \verb|^$|. \verb|^| znaèí zaèátek øetìzce a \$ konec øetìzce. V angliètinì se nazıvají \uv{anchors} (kotvy). Tyto metaznaky se odlišují tím, e nezachycují ádnı znak v øetìzci, ale pouze pozici. Napøíklad regulární vıraz: \verb|^abc$| uspìje pouze na øetìzci:\uv{abc}, ale neuspìje na øetìzci \uv{abcc} nebo \uv{aabc}. Pøi pouití pouze jednoho z uvedenıch napøíklad regulární vıraz \verb|^abc| uspìje na øetìzci \uv{\textbf{abc}c}, ale ne na \uv{aabc}. Analogicky regulární vıraz \verb|abc$| uspìje jak na øetìzci \uv{abc}, tak i na \uv{a\textbf{abc}}, ovšem sele na \uv{abcc}. \cite[s.37--40]{5}

Dùleité pøi pouívání tzv. kotev v regulárních vırazech je, e nezachycují zaèátek a konec øádku. Zachytí tedy celı víceøádkovı øetìzec. Tato vlastnost se dá zmìnit za pomocí \uv{multiline} módu.

\begin{table}[]
\centering
\caption[Multiline mód (viz. \cite{5})]{Multiline mód}
\label{tab: tab3}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|l|}{Dot all}                                                          \\ \hline
Java       & Pattern.MULTILINE                                                         \\ \hline
Perl       & \verb|/m|                                                                       \\ \hline
AWK        & \begin{tabular}[c]{@{}l@{}}dá se nastavit pomocí \\  FS="\verb|\n|" \end{tabular} \\ \hline
Javascript & \verb|/m|                                                                        \\ \hline
PCRE       & \verb|/m|                                                                        \\ \hline
\end{tabular}
\end{table}



Kulaté závorky () slouí pro zachycení èásti regulárního vırazu. Toto má celou øadu vyuití napøíklad za úèelem alternace, nahrazení, opakování apod. Podrobnìji se kulatımi závorkami budu vìnovat v kapitole Zachycení (capture).

Metaznak \textbf{$\vert$} znaèí alternaci neboli logické \uv{nebo}. Jako pøíklad uvedu regulární vıraz \verb!(abd|abc)(dh|d|de)! s øetìzcem \uv{abcde} nejprve porovná první èást tzn. \verb|abd|, zde najde shodu pouze pro \uv{ab},a proto udìlá backtracking a zkusí porovnat s \verb|abc|. Zde najde shodu a pokraèuje další èástí vırazu. Nejprve vyhledává \verb|dh|. Zde najde shodu pouze pro \uv{d}, provede tedy backtracking a pøejde k vyhledávání \uv{d}. Najde shodu a ukonèí se vyhledávání, protoe regulární vıraz ji neobsahuje ádnou další skupinu. Vısledek vyhledávání je zvıraznìn v øetìzci tuènì \uv{\textbf{abcd}e}.

\subsection{Tøída znakù}
Velmi uiteèná je také tøída znakù \verb|[]|. Tøída znakù slouí k rozpoznání libovolného znaku nebo nìkolika znakù uvnitø hranatıch závorek. Regulární vıraz \verb|[abc]| zachytí buï \uv{a} nebo \uv{b} nebo \uv{c}. Uvnitø tøídy znakù lze pouívat všechny metaznaky krom \verb|^\-| a \verb|]| bez zpìtného lomítka, jeliko uvnitø hranatıch závorek ztrácejí svojí speciální funkci. V jazycích Java a .NET mezi metaznaky v tøídì znakù patøí také \verb|[|.[s.31--32]{5}

To proto, e tøída znakù v jazyce Java také umoòuje intersekce. Syntaxe intersekcí je následující: \verb|[tøída&&[intersekce]]|. Pomocí intersekce je moné napøíklad vynechat nìkteré znaky, které by jinak zahrnoval interval. Regulární vıraz \verb|[ac-fh-qs-y]| tak mùeme zapsat následovnì: \verb|[a-z&&[^bgrz]]|.\cite{9}


 
NEMELO BY JIT [A-z]

Znak \verb|^| uvnitø tøídy znakù znaèí negaci, èili regulární vıraz: \verb|a[^abc]c| uspìje na øetìzci \uv{\textbf{adc}}, ale sele na \uv{abc}. Je tøeba brát v potaz, e v regulárním vırazu \verb|[a^bc]|, kde není \verb|^| na prvním místì, se \verb|^| chová jako literál. Znak - je mimo hranaté závorky literál, ovšem uvnitø hranatıch závorek slouí k zapsání tøídy znakù jako interval. Regulární vıraz: \verb|[0-9A-Za-z]*| uspìje na øetìzci \uv{\textbf{A9g}}, ale sele na \uv{è} jeliko implicitnì jsou rozeznány pouze znaky z ASCII tabulky.  Toto platí pouze v pøípadì, e se  - nenachází hned za uvozující závorkou tzn.\verb|[-a]| nebo hned pøed uzavírající závorkou tzn.\verb|[a-]|. V uvedenıch pøíkladech se pak - chová jako literál.\cite[s.31--32]{5} 

Jako zjednodušení pro vıše popsanou tøídu znakù, existují zkratky tzv.\uv{tokeny}. Znak \verb|\w| je ekvivalentní s \verb|[A-Za-z0-9_]| a to v jazyce Java, Javascript a PCRE. Jazyky .NET a Perl umoòují \verb|\w| zachytit i znaky mimo ASCII tabulku (z èeskıch znakù napø. ı,á,í nebo é). 

K tøídì znakù \verb|[0-9]| je ekvivalentní znak \verb|\d|. 

Dalším pouívanım znakem je  bílı znak \verb|\s|. Bílım znakem rozumíme znak, kterı oznaèuje prázdné místo\cite{6}. Mezi bílé znaky ve všech modifikacích regulárních vırazù patøí tabulátor \verb|\t|, nová øádka \verb|\n|, konec stránky \verb|\f|,vertikální tabulátor\verb|\v|, mezeru a znak, kterı posune kurzor na zaèátek stránky \verb|\r|. Všechny jazyky podporující Unicode vlastnosti, podporují i všechny bílé znaky v Unicode tabulce. Vıjimkou jsou jazyky Java a PCRE. Horizontální tabulátor podporuje PCRE a Java8. \cite{8}

Pro získání negace znakù \verb|\w|, \verb|\d| a \verb|\s|, pouíváme velká písmena \verb|\W|,\verb|\D| a \verb|\S|.

Pro zachycení znakù na zaèátku nebo konci slova lze pouít znak \verb|\b|. Napøíklad regulární vıraz \verb|\ba..g\b| uspìje na øetìzci \uv{\textbf{assg}}, ale sele pøi rozpoznání \uv{abbgc}. Znak \verb|\B| hledá pozice, které jsou: pøed prvním nebo za posledním znakem slova (pokud posledním znak není znak slova), mezi dvìma znaky slova nebo jinımi znaky, a prázdnı øetìzec. V jazycích Javascript, Perl,.NET, PCRE a Python zachytí pozici mezi znaky rozpoznanımi \verb|\w| a \verb|\W|. Javascript a PCRE rozeznají pouze ASCII znaky na kraji slova, zatímco .NET, Java a Perl rozeznají jakékoliv znaky na kraji slova. Python umoòuje rozeznat i jiné ne ASCII znaky, pokud pouijeme modifikátor Unicode.\cite[s.42--43]{5}


\subsection{Kvantifikátory}
Další skupinou metaznakù jsou kvantifikátory umoòující opakování jednoho znaku nebo v kulatıch závorkách () zachycenou skupinu znakù.

Kvantifikátory a interval poètu opakování lze vidìt v tabulce 4. 
\begin{table}[h]
\centering
\caption[Kvantifikátory (viz. \cite{5})]{Kvantifikátory}
\label{tab:tab4}
\begin{tabular}{|c|c|}
\hline
Kvantifikátor & Poèet opakování \\ \hline
\verb|*| & \textless 0;\infty) \\ \hline
\verb|+| & \textless 1;\infty) \\ \hline
\verb|?| & 0 nebo 1\\ \hline
\end{tabular}
\end{table}

Sloené závorky \verb|{}| té slouí jako kvantifikátor. Umoòují zadat pøesnı poèet opakování napø. \verb|a{3}bc| uspìje na øetìzci \uv{\textbf{aaabc}}, protoe obsahuje znak \uv{a} tøikrát za sebou. Sloené závorky dále umoòují nastavit minimum a maximum opakování napø. \verb|a{1,3}bc| uspìje na øetìzcích \uv{abc}, \uv{aabc} i \uv{aaabc}. Další moností, kterou sloené závorky nabízejí, je nastavit minimální poèet opakování napø. \verb|a{2,}| uspìje na všech øetìzcích, které obsahují minimálnì dvì \uv{a} za sebou. \cite{10}

\subsection{Hladové vs. líné kvantifikátory}
Všechny vıše uvedené kvantifikátory jsou implicitnì nastaveny jako \uv{hladové} (anglicky \uv{greedy}). To znamená, e kvantifikátor pohltí, co nejvíce znakù, za kterımi je umístìn. Toto chování vysvìtlím na pøíkladì.

Mìjme regulární vıraz \verb|.*abc| a textovı øetìzec \uv{aabcaabc}. Kvantifikátor \verb|*| nejprve pohltí veškeré znaky øetìzce. Poté se bude snait najít další znak \uv{a}. Na tomto znaku, ale sele, jeliko v øetìzci u nezbıvá ádnı další znak. Proto se provede \mbox{\uv{backtracking}}, tak e postupnì odebírá odzadu znaky, které pohltil kvantifikátor. To je moné díky tomu, e si zapamatovává pozice pohlcenıch znakù. Tím se vrátí na pozici \uv{c} a znovu ovìøí, zda znak na dané pozici je \uv{a}. Zde sele, proto vrátí další znak, \uv{b}. Opìt sele a vrátí se na znak \uv{a}. Regulární vıraz zde uspìje a pokraèuje znaky \uv{b} a \uv{c}. Nakonec tedy regulární vıraz na daném øetìzci uspìje. \cite[s.68]{5}

\uv{Hladové} chování kvantifikátorù mùeme zmìnit na \uv{líné} (anglicky \uv{lazy}), tak e na kvantifikátor pøidáme \uv{?}. Dostaneme tedy \verb|*?|,\verb|+?|,\verb|??| a \verb|{}?|. Po zmìnì kvantifikátoru na lazy ve vıše uvedeném regulárním vırazu, zíkáme \verb|.*?abc|. Nyní se na øetìzci \uv{aabcaabc} provádí po kadém uspìšném rozeznání znaku \uv{a} \uv{backtracking}, aby se ovìøilo zda na následujících pozicích není \uv{b} a \uv{c}. \uv{Línı} kvantifikátor tak opakuje znakù, co nejménì to jde. V uvedeném øetìzci tedy nalezne pouze \uv{\textbf{aabc}aabc} \cite[s.69]{5}

Na obrázku 2 lze vidìt srovnání postupu pøi rozpoznávání stejného øetìzce pomocí regulárního vırazu s linım a ravım kvantifikátorem.
\begin{figure}[h!]
	\centering
		\includegraphics{lazy.PNG}
	\caption{Línı a ravı kvantifikátor}
	\label{fig:obr2}
\end{figure}

\section{Optimalizace regulárních vırazù}
Optimalizace regulárních vırazù spoèítá v redukci poètu krokù, provedenıch pøi vyhodnocování regulárního vırazu. Následující metody mohou optimalizovat regulární vırazy zejména v pøípadech, kdy má regulární vıraz na daném øetìzci selhat.\cite[s.45]{6}
\subsection{Posesivní kvantifikátory}
Jak bylo moné vidìt na obrázku 2, \uv{hladové} i \uv{líné} chování kvantifikátorù vyaduje mnohdy pøebyteènı backtracking. Tomu lze pøedejít pouitím posesivních kvantifikátorù. Ty dostaneme pøidáním \verb|+| za kvantifikátor, tedy: \verb|*+|,\verb|++|,\verb|?+| a \verb|{}+|. Jsou podporovány pouze v jazycích Java (od verze 4), PCRE a Perl (od verze 5.10).

Posesivní kvantifikátor se chová podobnì jako \uv{hladovı}, ovšem po pohlcení všech monıch vıskytù daného znaku, ji neprovádí backtracking a ádnı ji pohlcenı znak nevrací. Nezapamatovává si toti pozice. Stejnı regulární vıraz jako v pøedchozích pøípadech, pøi pouití posesivního kvantifikátoru, \verb|.*+abc| pak na øetìzci \uv{aaaabc} neuspìje.
Kvantifikátor toti pohltí všechny znaky v øetìzci a pøi porovnávání znaku \uv{a} za kvantifikátorem sele, protoe se neprovede backtracking. (viz. obrázek 4).\cite[s.70-71]{5}

 \begin{figure}[h!]
	\centering
		\includegraphics{possessive.PNG}
	\caption{Posesivní kvantifikátory}
	\label{fig:obr4}
\end{figure}

\subsection{Atomické seskupení}
Další moností, jak se pøedejít pøebyteènému backtrackingu, je pouití atomického seskupení \verb|(?> vıraz)|. Tato syntaxe umoòuje do závorek umístit jakoukoliv èást regulárního vırazu, v rámci kterého si nepøejeme provádìt backtracking (tzn. vıraz uvnitø závorek je \uv{nedìlitelnı}). Podobnì jako u posesivních kvantifikátorù se uvnitø kulatıch závorek nezapamatovávají pozice pro backtracking. 

Vyuití bychom mohli najít napøíklad pøi alternaci. Regulární vıraz \verb|(?>bc|b)c| uspìje pouze na \uv{bcc}, nikoliv na \uv{bc}. \cite[s.72]{5}

Atomické seskupování není podporováno v jazyce Javascript a AWK.



 \begin{figure}[h!]
	\centering
		\includegraphics{srovnani.PNG}
	\caption{Srovnání poètu krokù v jazyce PCRE (php)}
	\label{fig:obr5}
\end{figure}

\section{UNICODE vlastnosti}
Unicode Standard a ISO/IEC 10646 podporují UTF--8, UTF--16 a UTF--32.\cite{11} Co umoòuje pøevést libovolné znaky do strojovì èitelného textu. Nejnovìjší verzí standardu Unicode je verze 8.0. Je podporováno mnoha jazyky vèetnì Javascriptu dle normy ECMAScript-262 6. edice, nicménì AWK jej nepodporuje.

Pro unicodové znaky (tzv. grafémy) mohou mít napøíklad tvar \verb|\u2122|, co je podporovanı tvar jazyky Javascript a Java (za pøedpokladu zapnutí módu unicode \verb|u|), nebo \verb|\x{2122}| podporované jazykem Perl nebo PCRE. Tvar \verb|\u+0000| umoòuje pouít právì 4 hexa èíslice, zatímco \verb|\x{00}| umoòuje pouít pøávì tolik hexa èíslic, kolik je potøeba.

V regulárních vırazech mùeme pouít i unicodové vlastnosti (anglicky property). \verb|\p{vlastnost}| pak reprezentuje jakıkoliv znak s danou vlastností ve sloenıch závorkách. Pokud chceme její negaci pouijeme \verb|\P{vlastnost}|. Tuto funkci podporuje pouze Java, Perl, PCRE a .NET. (ne Javascript ani awk)

\verb|\p{L}| pøedstavuje jakékoliv písmeno z kteréhokoliv jazyka. Mùeme tuto vlastnost doplnit \verb|\p{Lu}|, co znaèí velké písmeno nebo \verb|\p{Ll}|, co znaèí malé písmeno.
\verb|\p{Z}| zachytí mezeru nebo neviditelnı separátor. Tuto vlastnost mùeme upøesnit \verb|\p{Zs}|, co znaèí neviditelnı prázdnı znak nebo \verb|\p{Zl}| znaèící oddìlovaè øádkù U+2028 èi \verb|\p{Zp}| pro oddìlovaè odstavcù U+2029.
Pro matematické symboly, znaky mìn apod. mùeme pouít \verb|\p{S}|. Pro èísla existuje vlastnost \verb|\p{N}|, která zachytí veškerá èísla od 0 do 9 i øímské èíslice.
Interpunkci (tzn. teèka, èárka, uvozovky, závorky apod..) je moné zachytit pomocí \verb|\p{P}|. Pro teèku a èárku mùeme pouít \verb|\p{Pd}|, pro otevírací závorku \verb|\p{Ps}| a uzavírající závorku \verb|\p{Pe}|. \cite[s.45-47]{5}

Unicode bloky jsou tvoøeny seskupenımi unicodovımi znaky. Jsou podporovány pouze v jazyce Perl, .NET a Java. Syntaxe \verb|\p{nazev_bloku}| se ovšem v rùznıch jazycích mùe lišit. Java pouívá vdy pøed názvem bloku ve sloenıch závorkách \uv{In} (napø. \verb|\p{InBasicLatin}|) , Perl umoòuje jak \uv{In} tak \uv{Is}. Názvù blokù je celá øada, napøíklad blok pro znaky \verb|0000..007F| se nazıvá Basic\verb|_|Latin, \verb|0400..04FF| pro Cyrilici nebo \\ \verb|0600..06FF| pro arabské znaky (více viz. \cite{12}). \cite[s.44]{5}
V jazyce Javascript jde stejného vısledku dosáhnout pomocí tøídy znakù napø. \verb|/[\u0400-\u04FF]+/|.  

Synataxe pro unicode písma \verb|\p{nazev_skriptu}| je podporována v Javì (od verze 7), PCRE i Perlu. Java vyaduje pøed názvem skriptu ještì \uv{Is} (napø. \verb|\p{IsGreek}|)\cite{13}. Názvy unicodovıch skriptù jsou napøíklad: \uv{Latin},\uv{Arabic},\uv{Brahmi} nebo od verze 8 také \uv{Multani}\cite{14}.


\section{Look Around}
\uv{Look around} rozpoznává pozici v textu. Kontroluje pouze shodu bez toho, aby danı text pohltil. Bohuel nejsou podporovány jazykem AWK. Existují ètyøi druhy look around.

\uv{Pozitivní lookahead} \verb|(?= ... )| uspìje, pouze pokud doprava od dané pozice se nachazí øetìzec vyhovující regulárnímu vırazu v kulatıch závorkách. Je podporován v jazycích Java, Javascript, Perl a PCRE. Napøíklad regulární vıraz \verb|cat(?=dog)| uspìje na øetìzci \uv{\textbf{cat}dog}(pozn. zachytí se pouze zvıraznìná èást).

\uv{Negativní lookahead} \verb|(?! ... )| neuspìje, pokud se doprava od dané pozice nachází øetìzec vyhovující regulárnímu vırazu v závorkách. Znamená to tedy, e regulární vıraz \verb|cat(?!dog)| neuspìje na øetìzci \uv{catdog}, ale upspìje na \uv{\textbf{cat}s}. Je podporován v jazyce Java, Javascript, Perl i PCRE. 

\uv{Pozitivní lookbehind} \verb|(?<= ... )| uspìje, pouze pokud doleva od dané pozice se nachazí øetìzec vyhovující regulárnímu vırazu v kulatıch závorkách. Je podporován v jazycích Java, Perl a PCRE. Regulární vıraz \verb|(?<=bc)df| uspìje na \uv{bc\textbf{df}}.

\uv{Negativní lookbehind} \verb|(?<! ... )| se chová podobnì jako negativní lookahead, s tím rozdílem, e kontroluje øetìzec doleva od dané pozice. Regulární vıraz \verb|(?<!bc)df| neuspìje na øetìzci \uv{bcdf}, ale na \uv{aa\textbf{df}} ano. Negativní lookbehind je podporován v jazycích Java, Perl a PCRE.

Negativní a pozitivní lookbehind nepodporuje kvantifikátory, které umoòují nekoneèné opakování jako \verb|* + {1,}|. To proto, e  \cite[s.75-77]{5}

\section{Zachycování (capture)}
Zachycování neboli anglicky \uv{capture} slouí k zachycení urèité èásti vırazu. K tomu slouí kulaté závorky () (viz. podkapitola Metaznaky). Zachycení pak má celou øadu vyuití jako napø. za úèelem nahrazení, zpìtné odkazy atd... Text je pak zachycen v oddìlenıch skupinách, které se èíslují od jedné do nekoneèna.

V pøípadì, e nechceme, aby regulární vıraz zachytil nìkterou èást textu mùeme danou èást umístit do \verb|(?: ... )|. Tatot syntaxe se dá vyuít zejména pøi alternaci (viz. podkapitola Metaznaky). Regulární vıraz \verb|(jablka) (?:a|nebo) (hrušky)| na øetìzci \uv{jablka a hrušky} zachytí \uv{jablka} jako první skupinu a \uv{hrušky} jako druhou skupinu. Narozdíl od \verb|(jablka) (a|nebo) (hrušky)|, kde druhá skupina obsahuje \uv{a} a \uv{hrušky} jsou obsaeny a ve tøetí skupinì.
Tato syntaxe je podporována v jazyce Java, Perl i Javascript. Jazyk Perl navíc umoòuje nezachycení èásti v kulatıch závorkách pomocí vlajeèky \textit{n}.

Dle oznaèení skupin je pak moné se na nì odkazovat. V jazycích Perl, Javascript nebo Java je moné odkazovat na zachycenı text pomocí zpìtného lomítka a èísla dané skupiny (napø. \verb|\1| odkazuje na první zachycenou skupinu ve vırazu). Regulární vıraz \verb!(\w)(\w)\2\1!, pak uspìje na øetìzci \uv{alla}. Jazyk Perl umoòuje dojít ke stejnému vısledku i pøi pouití jiné syntaxe \verb|(\w)(\w)\g2\g1|. Jazyk AWK ukládá text do pole, tudí se s ním mùe dále pracovat jako s polokami v poli (viz. kapitola AWK).

Regulární vırazy také umoòují zachycené skupiny pojmenovávat a pak na nì odkazovat pomocí daného názvu, pomocí sytaxe \verb|(?P<nazev>...)(?P=nazev)| v jazyce Perl nebo \verb|(\k<nazev>...)\k<nazev)>|. Vıše uvedenı regulární vıraz dospìje ke stejnému vısledku i touto syntaxí : \verb|(?P<ovoce>jablka) a (?P=ovoce)| nebo \verb|(?<ovoce>jablka) a \k<ovoce>|. Pojmenovávání skupin není podporováno v jazyce Javascript a AWK.

%jazyky s vestavenou podporou ---------------------
\chapter{Regulární vırazy v programovacích jazycích}
\section{Perl}
\subsection{Obecné informace}
Jazyk Perl je skriptovací programovací jazyk vyvynut jako náhrada jazyku AWK. Nejnovìjší verzí je verze 5, ovšem v roce 2000 zapoèaly práce na Perl 6. Verze 6 se ale dodnes nedoèkala vydání. V této kapitole budu tedy popisovat monosti a vyuití regulárních vırazù v Perl 5 verzi 22.0.\cite{15}

\subsection{Rozšíøení podporováno v jazyce Perl}
Veškerá syntaxe regulárních vırazù specifickıch pro Perl je popsána v knihovnì \uv{re}. Napøíklad Perl umoòuje rozšíøení tøídy znakù \verb|/(?[ ...])/|. Tato syntaxe podporuje jak intersekci \verb|&|, substrakci - èi logické nebo \verb|+|.

Krom vıše uvedenıch modifikátorù Perl umoòuje také modifikátor \uv{a}, kterı zajišuje rozpoznávání pouze znakù z ASCII tabulky.

Stejnì jaké AWK, také umoòuje pouívání POSIX syntaxy pro zkratky tøíd znakù (viz. AWK).\cite{16}

\subsection{Syntaxe}

Regulární vıraz se podobnì jako v dalších jazycích zapisuje mezi dvì lomítka \verb|/.../|. Perl také umoòuje další zápisy \verb|m!...!| nebo \verb|m{...}|, které jsou s vıše uvedenım ekvivalentní.
Zapnutí rùznıch módù je pak umonìno zápisem daného modifikátoru za druhé lomítko napøíklad \verb|/.../s|.\cite{16}

Pro práci s regulárními vırazy pouívá Perl operátory \verb|s///|,\verb|gr//| a \verb|split|.\cite{16}

Porovnávání regulárního vırazu a textového øetìzce lze pak provádìt pomocí operátorù vracející booleanovské hodnoty (true a false):
\begin{itemize}
\item  \verb|=~|, kterı vrací \textit{true}  pokud vıraz uspìje, v opaèném pøípadì vrací \textit{false} 
 \item \verb|!~|, kterı vrací \textit{true} v pøípadì, e vıraz neuspìje
\end{itemize}

\begin{lstlisting}
"cats" =~ /cat/  #true
"cats" !~ /cat/ #false
\end{lstlisting}

Perl si zapamatovává pozice shody i bez pouití kulatıch závorek a to poèáteèní pozici \verb|$-| a koneènou pozici \verb|$+|. Shodu pak mùeme jednoduše zobrazit pomocí metody \textit{substr()} se tøemi paramentry. Prvním parametrem je zadanı øetìzec, druhım poèáteèní index a tøetím délka. \cite{16}

\begin{lstlisting}
$x = "The cat caught the mouse";
if($x=~/cat/){ 
    	$found = substr($x,$-[0],$+[0]-$-[0]);
      print "Nalezeno: $found na pozici od $-[0] do $+[0]";
    }
	# vytiskne: Nalezeno: cat na pozici od 4 do 7
\end{lstlisting}

Nalezenou shodu lze také získat pomocí promìnnıch \verb|$&| nebo \verb|${^MATCH}|.\cite{16}

V pøípadì, e chceme nalézt veškeré shody vzoru se zadanım textem, mùeme všechny vısledky uloit do pole. V pøípadì pouití kulatıch závorek zachycuje se shoda s regulárním vırazem v závorce do samostatné poloky pole.\cite{16}

\begin{lstlisting}
@matches = ($x=~/\b\w{3}\b/g); 
# matches[0] = 'The'
# matches[1] ='cat'
# matches[2] ='the'
\end{lstlisting}

Ji vıše zmínìnı operátor split se syntaxí: \verb|split /vzor/,"retezec"| umoòuje øetìzec rozdìlit dle zadaného vzoru. Vısledkem je pak opìt pole. \cite{16}

\begin{lstlisting}
$y = "+420895895895 +421965896854 +420598632412";
 @pole = split /\+\d{3}/,$y;
# pole[0] = '895895895 '
# pole[1] = '965896854 '
# pole[2] = '598632412 '
\end{lstlisting} 

Dalším opeátorem je operátor \uv{vyhledání a nahrazení} \verb|s///|, jeho pouití je dáno syntaxí je \verb|s/regulární vıraz/nahrazení/modifikátory|. 
\begin{lstlisting}
$g = "Bylo nás 5";
$g =~ s/5/pìt/;
#$g = Bylo nás pìt
\end{lstlisting}
Pøi nahrazování vırazu na více místech v øetìzci, je tøeba pouít vlajeèku \verb|g|.\cite{16}

Vıše uvedenım pouitím se nahradí stávající øetìzec. Tomu se lze vyhnout pomocí modifikátoru \verb|r|. Bez jejího pouití se do pomocné promìnné uloí pouze èíslo substituce.\cite{16}
\begin{lstlisting}
$g = "Bylo nás 5";
$d = $g =~ s/5/pìt/r;

#$g = "Bylo nás 5"
#$d = "Bylo nás pìt"
\end{lstlisting}
Vlajeèka umoòuje také øetìzení substitucí, kde se provádí nahrazení v ji jednou (nebo vícekrát) zmìnìném øetìzci.\cite{16}

Pouitím vıše uvedené syntaxe se regulární vıraz pøi pouítí v kódu na více místech bude pokadé znovu pøekládat. Øešením je operátor \verb|gr//|. \cite{16}


\section{GNU implementace regulárních vırazù}
GNU je zkratka pro \uv{GNU's Not Unix} (GNU není Unix) je projekt, kterı mìl za cíl vytvoøení operaèního systému, kterı by byl otevøenı všem a zároveò byl kompatibilní s Unix. Zahrnuje dvì skupiny programù pouívajících regulární vırazy: Základní BRE neboli \uv{Basic Regular Expressions} jako napø. grep a rozšiøující ERE neboli \uv{Extended Regular Expressions} jako napø. awk nebo egrep, které umoòují pouití dalších funkcí. Obì skupiny jsou zaloeny na POSIX standardu. Rozdílem mezi nimi je, e BRE pouívá zpìtná lomítka pro pøidání speciálních funkcí metaznakùm a naopak u ERE pouivá zpìtná lomítka pro odebrání speciálních funkcí metaznakù.\cite{17}

\section{AWK}
\subsection{Obecné informace}
AWK je jak poèítaèovım programem, tak i programovacím jazykem, kterı umoòuje danı program ovládat. Je zahrnut témìø ve všech UNIX systémech. Slouí zejména ke zpracování textovıch dat. K tomu hojnì vyuívá regulární vırazy. Pøíchu regulárních vırazù v jazyce AWK je dána POSIX standardem. Jazyk AWK byl vynalezen ji v roce 1977 a od té doby vzniklo nìkolik jeho rozšíøení. Jednou z verzí je nawk neboli \uv{nové awk} (anglicky new awk) nebo gawk neboli GNU awk, které pøináší øadu rozšíøení a to i z hlediska regulárních vırazù.

\subsection{Syntaxe}
Syntaxe v AWK se vyznaèuje nìkolika odlištnostmi od ostatních modifikací regulárních vırazù. Regulární vıraz se zapisuje mezi dvì lomítka \verb|(/ ... /)|. AWK umoòuje porovnávání øetìzcù pomocí operátorù \verb|~| a \verb|!~|. Syntaxe \verb|pozice ~ /regVyraz/| umoòuje vyhledat všechny vırazy, které odpovídají vzoru. \verb|pozice ~! /regVyraz/| umoòuje naopak najít všechny vırazy na dané pozici, které vzoru neodpovídají. \cite[s.45]{17}

Další odlišností, která nebyla v pøechozím textu zmínìna, je pouívání odlišnıch zktratek pro tøídu znakù. AWK umoòuje pouívat tøídu znakù definovanou POSIX standardem, pomocí \verb|[:nazevTridy:]|. Seznam níe uvádí pøehled názvù tøíd a jejich popis. \cite[s.51]{18}
\begin{itemize}
\item \verb|[:alnum:]| veškeré alfanumerické znaky
\item \verb|[:alpha:]| veškeré znaky písmen
\item \verb|[:blank:]| mezera a tabulátor
\item \verb|[:cntrl:]| control znaky
\item \verb|[:digit:]| èísla
\item \verb|[:graph:]| tištitelné a viditelné znaky napø. \uv{k}
\item \verb|[:lower:]| malá písmena
\item \verb|[:print:]| tištitelné znaky
\item \verb|[:punct:]| interpunkce, která nespadá ani do jedné z vıše uvedenıch skupin
\item \verb|[:upper:]| kapitálky
\item \verb|[:xdigit:]| znaky v hexadecimálním tvaru
\end{itemize}
Tøídu znakù je nutné zapisovat do dvojitıch hranatıch závorek napø. \verb|[[:alpha:]]|. 

AWK ète zadanı pøíkaz dvakrát. Poprvé pøeète zadanı program a podruhé vyhledá øetìzec vyhovující zadanému regulárnímu vırazu.\cite[s.53]{18}

Jak ji bylo zmínìno vıše , AWK má implicitnì nastaven mód \uv{single line}. Pøi naèítání souboru rozdìluje vloenı text do záznamù oddìlené právì znakem nové øádky \uv{\n}. Pro zmìnu separátoru mùeme nastavit promìnnou \uz{RS} na jakıkoli jeden znak nebo prázdnı øetìzec.

Záznamy jsou pak dále dìleny na pole, která jsou lépe programovì zpracovatelná (program si toti zapamatovává jejich pozice pomocí poètu záznamù, které ji byly pøeèteny). Separátor rozdìlující pole je buï jakıkoli znak (vèetnì mezery) nebo regulární vıraz. Separátor mùeme nastavit pomocí promìnné \uv{FS}. 

\begin{lstlisting}
echo Jimmy Weasel, 100 Any Street#Jane Weasel, 99 Same Street | 
awk 'BEGIN{RS="#"; FS=","} /.+/ {print $1}'

#vytiskne: 
#Jimmy Weasel
#Jane Weasel

\end{lstlisting}

Pro nahrazování pouijeme metodu \textit{sub()}, která má dva paramentry. Prvním parametrem je regulární vıraz a druhım øetìzec, kterı má nahradit vyhledanou èást.

\begin{lstlisting}
echo abcdefg| awk '{sub(/abc/,"cba");print}'
# vytiskne "cbadefg" 
\end{lstlisting}

AWK umoòuje pøevést vloenı øetìzec do malıch èi velkıch písmen, a to pomocí metod \textit{tolower()} a \textit{toupper()}.

Dále také má funkci \textit{split()}, která slouí pro rozdìlení øetìzce dle zadaného vzoru. 

\subsection{Rozšíøení gawk}
Jak bylo ji zmínìno v úvodu této kapitoly, GNU awk neboli gawk umoòuje øadu rozšíøení oproti awk.

Podporuje pouívání tzv. tokenù (viz. ...) a to: \verb|\s|, \verb|\w| a jejich negace a \verb|\B|. \verb|\b| v awk znaèí zpìtné lomítko, proto je zde token hranice slova znaèen jako \verb|\y|.
Dále také umoòuje pouívání dalších: \verb|\<| zachycující práznı øetìzec na zaèátku slova a \verb|\>| zachycující prázdnı øetìzec na konci slova. 

Oproti awk také umoòuje zapnout mód case-insensitive. Pomocí promìnné IGNORECASE, která je implicitnì nastavena na 0. Po zmìnì dané promìnné na 1 (tzn. IGNORECASE = 1), veškeré regulární vırazy a celı program budou mít zapnutı mód case-insensitive. 

\section{grep}
Grep je nástroj, kterı primárnì slouí k vyhledávání souborù dle názvu za pomocí regulárních vırazù. Pouití má následující syntaxi: 
\begin{lstlisting}
grep [parametr] 'vzor' soubor
\end{lstlisting}

Parametrù mùe bıt hned nìkolik. Napøíklad \verb|-E| umoòuje pouití syntaxe vzoru z ERE. Dalšími jsou parametry, kterımi lze nastavit, jakı vıstup vyhledávání chceme. Napøíklad \verb|-l| vypíše názvy všech názvù souborù, které odpovídají zadanému vzoru. Naopak \verb|-L| zajistí vıpis všech souborù, jejich názvy vzoru neodpovídají. \cite{19}
 Parametr \verb|-r| umoòuje rekursivní vyhledávání ve sloce.
\begin{lstlisting}
grep -lr '[Ww]ork' /home/projects
\end{lstlisting}
Ve vıše uvedeném pøíkladu se vypíše do konzole seznam všech souborù ve sloce \uv{projects}, které obsahují slova \uv{Work} nebo \uv{work}. Pokud bychom chtìli zjistit, na kterém míste se v souboru shoda nachází, staèí jako parametr zadat pouze \verb|-r|. \cite{19}
 
\section{Javascript}
\subsection{Obecné informace}
Javascript je objektovì orientovanı jazyk, pouívanı jako skriptovací jazyk pro webové stránky. Nicménì je spustitelnı i v nástroji node.js. Standardem pro Javascript je ECMAScript. Nejnovìjší verzí je ECMAScript 6 (neboli ECMA--262 6. edice) vydaná v roce 2015. Ovšem není podporován všemi internetovımi prohlíeèi ani nástrojem node.js, proto se v této kapitole budu dret syntaxe standardizovaném ECMAScript 5.1, která je plnì podporována.

ECMAScript 6 pøináší vıznamné novinky z hlediska syntaxe\footnote{Více informací o zmìnách lze nalézt zde: http://es6-features.org/}. Z hlediska regulárních vırazù byly pøidány dva modifikátory a to: \verb|\u| pro unicodové vlastnosti a \verb|\y| tzn. \uv{sticky matcher}, kterı umoòuje procházet zadanı textovı øetìzec od pozice dané v promìnné \textit{RegExp.lastIndex}.

\subsection{Syntaxe}

Regulární vırazy v Javascriptu se zapisují mezi dvì lomítka \verb|/.../| a mofigikátory, které chceme pouít se zapisují a nakonec, za druhé lomítko napø. \verb|/.../gim|.\cite{20}

Pokud chceme regulární vıraz pouít na více øetìzcù, lze objekt regulárního vırazu jednoduše vytvoøit pøiøazením promìnné. Objekt regulárního vırazu mùeme také vytvoøit z textového øetìzce pomocí konstruktoru \textit{RegExp}. Tento konstruktor mùe mít buï jeden parametr, obsahující regulární vıraz bez lomítek, a nebo dva parametry, z nich první obsahuje regulární vıraz bez lomítek a druhı vlajeèku. Pøi vytváøení objektu regulárního vırazu mùe dojít k vıjimce \textit{SyntaxError}, která, jak u název napovídá, je vyvolána pøi zadání vırazu s nesprávnou syntaxí.\cite{18}

\begin{lstlisting}
//Metoda zjištuje zda byla zadána i vlajeèka a poté vytvoøí regulární vıraz pomocí kontruktoru RegExp
function prevodReg(reg,f){
	var vystup;
	try{
		if(f == ""){
			//zadanı vıraz se pøevede do regulárního vırazu bez vlajeèky
			vystup = new RegExp(reg);
		}else{
			//zadanı vıraz se pøevede do regulárního vırazu i s vlajeèkou
			vystup = new RegExp(reg,f);	
		}
	}catch (error){
		//odchycení vıjimky SyntaxError
		console.log("SyntaxError: Nesprávnì zadanı vıraz");
		main();
	}
	return vystup;
};
\end{lstlisting}

Takto vytvoøenı RegExp objekt dìdí po svém pøedku metody:
\begin{itemize}
	\item \textit{RegExp.prototype.test()}, která otestuje, zda zadanı øetìzec odpovídá vzoru. Pøi nalezení shody vrací \textit{true}, v opaèném pøípadì \textit{false}.

   \item \textit{RegExp.prototype.exec()}, která vrací nalezenou èást øetìzce odpovídající zadanému vzoru. A to v podobì pole. V pøípadì, e nenajde ádnou shodu, vrací \textit{null}. Stejného vısledku docílíme i metodou \textit{String.prototype.match()}. Ta navíc umoòuje vloit jako parametr jak objekt RexExp tak i regulární vıraz v typu string.\cite{20}
	
\end{itemize}

\begin{lstlisting}
//Metoda zjišuje shodu zadaného vırazu (str) a vzorem (re)
	function zjistitShodu(re,str){
	
	//zjistí se, zda danı text odpovídá vzoru
	if(re.test(str)){
	
		//vrací substring odpovídající vzoru
		var newstr = str.match(re);
		
		//pouití RegExp.prototype.exec()
		//var newstr = re.exec(str);
		
		console.log(newstr);
	}else{
		console.log("ádná shoda");
	}
};
	\end{lstlisting}

Napøíklad pøi zadání regulárního vırazu: \verb|[12][0-9]{3}| a øetìzce \uv{v roce 1990}, vıøe uvedená metoda vypíše do konzole: \verb|['1990',index: 7,input: 'v roce 1990']|. Na první pozici se nachází èást øetìzce odpovídající vzoru. Index znaèí pozici, na které se nachází \uv{1990}. Input pak ukazuje vloenı øetìzec.

Pro nahrazení èásti øetìzce odpovídající danému vzoru, slouí metoda \textit{String.prototype.replace()}. Metoda vrací novı øetìzec tvoøenı pùvodním øetìzecem s nahrazenımi èástmi. Jako parametr mùe bıt pouit, jak regulární vıraz ve tvaru øetìzce (string), tak i jako objekt RegExp. Druhım parametrem je nahrazující øetìzec, kterı mùe bıt zadán jako string nebo jako metoda, která se zavolá pøi kadém pouití daného regulárního vırazu.. \cite{21}

\begin{lstlisting}
//metoda slouí k nahrazení èásti zadaného øetìzce (str), která odpovídá regulárnímu vırazu (reg)
//øetìzcem "repl"
function nahradit(reg,str,repl){
//zjistí, zda danı øetìzec odpovídá vzoru
	if(reg.test(str)){
		//nahradí zadanı text
		var newstr = str.replace(reg,repl);
		console.log(newstr);
		main();
	}else{
		console.log("ádná shoda");
		main();
	}
};
\end{lstlisting}

Metoda \textit{replace()} neumoòuje vkládat vlajeèky jako parametr. Toto omezení lze obejít vyuitím RegExp objektu. Na zachycené èásti textu (viz. podkapitola Zachycení), se lze odkazovat pomocí \verb|$d|, kde d pøedstavuje èíslo dané skupiny.\cite{21} 


\section{Java} 
\subsection{Obecné informace}
Jazyk Java je objektovım programovacím jazykem. Jeho první verze vyšla v roce 1995. Ve ètvrté verzi vydané v roce 2002, byl do Javy pøidán (mimo jiné) balíèek podporující regulární vırazy \textit{java.util.regex}. Java pouívá modifikaci regulárních vırazù velmi podobné jazyku Perl, co umoòuje v Javì pouívat i pokroèilé regulární vırazy.  Podpora dalších funkcí v regulárních vırazech pøišla s šestou verzí, kdy byla pøidána podpora unicodovıch skriptù (viz. podkapitola Unicode) a pojmenovávání zachycenıch skupin (viz. podkapitola Zachycování(capture)).

Vıznamnım odlišením od syntaxe regulárních vırazù v jinıch jazycích (vèetnì jazyku Perl) je pouití dvojitého zpìtného lomítka pøi \uv{escapování} v datovém typu String. Tudí je dùleité napøíklad místo \verb|\w| napsat \verb|\\w|. To proto, aby byly Java kompilátorem správnì pøeloeny. To platí i pro zapisování unicodovıch znakù.\cite{13}

Podobnì jako u ji zmínìnıch jazykù i Java má speciální znaky pro tøídu znakù definovanou POSIX standardem. Oproti ji vıše zmínìnıch programù awk èi grep, se v Javì pouívá jiná syntaxe (viz. seznam níe).
\begin{itemize}
	
\item  \verb|\p{Lower}|	je ekvivalentní zápis [a-z]
\item  \verb|\p{Upper}|	je ekvivalentní zápis [A-Z]
\item  \verb|\p{Alpha}|	je ekvivalentním zápisem [a-zA-Z]
\item  \verb|\p{Digit}|	je ekvivalentní zápis [0-9]
\item  \verb|\p{Alnum}|	je ekvivalentní s [a-zA-Z0-9]
\item  \verb|\p{Punct}|	je ekvivalentní s jakımkoli z \verb|!"#$%&'()*+,-./:;<=>?@[\]^_`{}~|\verb!|!
\item  \verb|\p{Graph}|	znaèí jakıkoliv viditelnı znak
\item  \verb|\p{Print}|	znaèí jakıkoliv viditelnı znak a mezeru
\item  \verb|\p{Blank}|	znaèí tabulátor

\end{itemize}

\subsection{Pouívané tøídy a metody}
Balíèek \textit{java.util.regex} obsahuje tøídy:
\begin{itemize}
	\item \textit{Pattern}, která provádí kontrolu syntaxe regulárního vırazu. Nemá veøejnı (public) kontruktor, k vytvoøení instance je proto tøeba \textit{public static Pattern compile(String regex)}. Parametrem je regulární vıraz typu String. Pøi volání této metody je monı vznik vıjimky \textit{PatternSyntaxException}. Tato vıjimka se nemusí povinnì odchytávat, ale je to vhodné v pøípadì, e regulární vıraz zadává uivatel. \cite{13}
\item \textit{Matcher}, která zajišuje porovnávání zadaného vzoru a textového øetìzce. Podobnì jako tøída Pattern, nemá veøejnı kontruktor. K jejímu vytvoøení je tøeba volání metody na instanci tøídy Pattern \textit{public Matcher matcher(CharSequence input)}.\cite{15} Tato metoda mùe vyvolat vıjimku \textit{NullPointerException} v pøípadì, e její parametr bude \textit{null}. Narozdíl od tøídy Pattern není vláknovì bezpeèná.
\end{itemize}
\begin{lstlisting}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

public class RegexLogika {

    private Pattern pattern;
    private Matcher m;
		
\end{lstlisting}

Tøída Matcher pak má metody:
\textit{public boolean matches()} umoòující porovnání øetìzce se zadanım vzorem.
\textit{public boolean find()} hledající poèátek èásti zadaného øetìzce, kterı odpovídá vzoru. Vrací true, v pøípadì, e øetìzec obsahuje èást (tzv. \uv{substring}) odpovídající vzoru. Vyhledanı substring, pak lze získat pomocí metody \textit{public String group()}. Metoda \textit{find()}, pøi prvním zavolání, prohledává zadanı øetìzec od zaèátku (tzn. od indexu 0). Nicménì pokud najde shodu a je zavolána podruhé, zaène vyhledávat od pozice za poslední nalezenou shodou. \cite{22}

\begin{lstlisting}
   /**
     * Metoda uplatní uivatelem zadanı vzor na uivatelem zadaném øetìzci
     * @param regex - vzor
     * @param vstup - textovı øetìzec
     * @return vyhledanı substring
     */
    public String vyhledat(String regex, String vstup) {
          List<String> vystup = new ArrayList<>();
        //regularni vyraz zadany uzivatelem
        try {
            pattern = Pattern.compile(regex);
        } catch (PatternSyntaxException e) {
            JOptionPane.showMessageDialog(null, " Chybnı regulární vıraz", "REGEX hlášení", JOptionPane.PLAIN_MESSAGE, null);
        }
        //vstup zadany uzivatelem
        try {
            m = pattern.matcher(vstup);
				//zjištìní, zda øetìzec obsahuje nìjakou shodu
            if (m.find()) {
                vystup.add(m.group());
				//hledání dalších shod øetìzce s regulárních vırazem        
                while (m.find()) {
                    vystup.add(m.group());
                }
            } else {
                JOptionPane.showMessageDialog(null, "ádná shoda", "REGEX hlášení", JOptionPane.PLAIN_MESSAGE, null);

            }

        } catch (NullPointerException ex) {
            JOptionPane.showMessageDialog(null, "ádná shoda", "REGEX hlášení", JOptionPane.PLAIN_MESSAGE, null);

        }
        return vystup;
    }
\end{lstlisting}

Metodu \textit{group()} mùeme nahradit:
\begin{lstlisting}
 //index prvního znaku nalzeného textu
 zacatek = m.start();
 //index posledního znaku nalezeného textu
 konec = m.end();
//vytvoøení substringu ze zadaného textu
 vystup = vstup.substring(zacatek, konec);
\end{lstlisting}

Java neumoòuje automaticky vyhledávat všechny vıskyty shody s regulárním vırazem, pouze pouitím modifikátoru \uv{g} jako napøíklad Perl (viz. Perl). Lze vyhledat všechny vıskyty opakovanım voláním metody \textit{group()} a ukládáním vısledkù napøíklad do seznamu.

Další metodou tøídy Matcher je \textit{public String replaceAll(String replacement)}, která zajistí nahrazení všech vıskytù nalezeného substringu v zadaném textu, textem èi odkazy udanımi v parametru metody.

K nahrazení pouze prvního vıskytu daného substringu slouí metoda \textit{public String replaceFirst(String replacement)}. Obì metody vrací objekt typu String, kterı obsahuje vıslednı øetìzec po nahrazení.

Parametr obou metod mùe obsahovat odkazy na zachycené skupiny (viz. kapitola Zachycení) za pomocí \verb|${nazevSkupiny}| nebo \verb|$d| (kde d znaèí èíslo skupiny). Jestlie nahrazovací text odkazuje na neexistující skupinu, vrátí se vıjimka IndexOutOfBoundsException. \cite{22}

\begin{lstlisting}
Pattern p = Pattern.compile("(\\w+)\\s(\\w+)");
Matcher m = p.matcher("John Smith");
String vysledek = m.replaceAll("$2 $1");
//promìnná vysledek je pak rovna "Smith John"
\end{lstlisting}


\section{PCRE}



\begin{thebibliography}{99}

 \bibitem[1]{1} DOSTÁL, Hubert. \emph{Teorie koneènıch automatù, regulárních gramatik, jazykù a vırazù} [online]. 2008 [cit. 2015-07-11]. Dostupné z: \verb|http://iris.uhk.cz/tein/teorie/regJazyk.html|
	
 \bibitem[2]{2} THOMPSON, Ken. \emph{Regular Expression Search Algorithm}. Communications of the ACM: Volume 11 [online]. 1968, (6): 419-422 [cit. 2015-07-11]. Dostupné z: http://www.fing.edu.uy/inco/cursos/intropln/material/p419-thompson.pdf
	
\bibitem[3]{3} Perl Compatible Regular Expressions. \emph{Wikipedia} [online]. 2015-07-03 [cit. 2015-07-11]. Dostupné z: \verb|https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions|

\bibitem[4]{4} Regular Expression. \emph{Wikipedia} [online]. 2015-07-08 [cit. 2015-07-11]. Dostupné z: \verb|https://en.wikipedia.org/wiki/Regular_expression|

\bibitem[5]{5} GOYVAERTS, Jan a Steven LEVITHAN. Regular Expressions Cookbook. 1. the United States of America: O’Reilly Media, Inc., 2009. ISBN 978-0-596-52068-7.

\bibitem[6]{6} GOYVAERTS, Jan. Regular Expressions: The Complete Tutorial [online]. 2007, July 2007 [cit. 2015-07-19]. Dostupné z: \verb|http://www.regular-expressions.info/print.html|

\bibitem[7]{7} Bílı znak. Wikipedie [online]. 2015-07-17 [cit. 2015-07-18]. Dostupné z: \verb|https://cs.wikipedia.org/wiki/B%C3%ADl%C3%BD_znak|

\bibitem[8]{8} Shorthand Character Classes. GOYVAERTS, Jan. Regular-Expressions.info [online]. 2014-04-24 [cit. 2015-07-18]. Dostupné z: \verb|http://www.regular-expressions.info/shorthand.html|

\bibitem[9]{9} Character Class Intersection. GOYVAERTS, Jan. Regular-Expressions.info [online]. 2014-09-26 [cit. 2015-07-19]. Dostupné z: \verb|http://www.regular-expressions.info/charclassintersect.html|

\bibitem[10]{10} The Java™ Tutorials. ORACLE. Oracle Java Documentation [online]. [cit. 2015-07-19]. Dostupné z: \verb|https://docs.oracle.com/javase/tutorial/essential/regex/quant.html|

\bibitem[11]{11} The Unicode® Standard: A Technical Introduction. UNICODE, INC. The Unicode Standard [online]. 2015-06-25 [cit. 2015-07-22]. Dostupné z: \verb|http://www.unicode.org/standard/principles.html#Unicode_and_ISO|

\bibitem[12]{12} Blocks. Unicode [online]. 2014-11-10 [cit. 2015-07-23]. \verb|Dostupné z: http://www.unicode.org/Public/UCD/latest/ucd/Blocks.txt|

\bibitem[13]{13} Class Pattern. ORACLE. \emph{Java™ Platform Standard Ed. 8 Documentation} [online]. 2015 [cit. 2015-07-25]. Dostupné z: \verb|https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html|

\bibitem[14]{14} Supported Scripts. UNICODE, INC. \emph{The Unicode Standard} [online]. 2015-06-12 [cit. 2015-07-25]. Dostupné z: \verb|http://unicode.org/standard/supported.html|

\bibitem[15]{15}Perl. \emph{Wikipedia: the free encyclopedia} [online]. San Francisco (CA): Wikimedia Foundation, 2015, 2015-06-03 [cit. 2015-08-15]. Dostupné z: \verb|https://cs.wikipedia.org/wiki/Perl|
\verb|#Budouc.C3.AD_v.C3.BDvoj_.28Perl_6_a_VM_Parrot.29|

\bibitem[16]{16}Perl regular expressions turtorial. KVALE, Mark. \textit{perldoc.perl.org: Perl Programming Documentation} [online]. 2000 [cit. 2015-08-15]. Dostupné z:\verb|http://perldoc.perl.org/perlretut.html|

\bibitem[17]{17}GNU Regular Expression Extensions. GOYVAERTS, Jan. \textit{Regular-Expressions.info} [online]. 2013-09-16 [cit. 2015-08-22]. Dostupné z: \verb|http://www.regular-expressions.info/gnu.html|

\bibitem[18]{18} ROBBINS, Arnold D. \textit{GAWK: Effective AWK Programming} [online]. Edition 4.1. USA: Free Software Foundation, 2015 [cit. 2015-07-28]. ISBN 1-882114-28-0. Dostupné z: \verb|http://www.gnu.org/software/gawk/manual/gawk.pdf|

\bibitem[19]{19} MAGLOIRE, Alain. \textit{GNU Grep: Print lines matching a pattern}. 2014. 2.21. Dostupné také z: \verb|http://www.gnu.org/software/grep/manual/grep.pdf|


\bibitem[20]{20}Regular Expressions. MOZILLA. Mozilla Developer Network [online]. 2015-07-21 [cit. 2015-07-26]. Dostupné z: \verb|https://developer.mozilla.org/en-US/docs/Web/JavaScript/|
\verb|Guide/Regular_Expressions|

\bibitem[21]{21}String.prototype.replace(). MOZILLA. Mozilla Developer Network [online]. 2015-07-13 [cit. 2015-07-27]. Dostupné z:\verb|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/|
\verb|Global_Objects/String/replace|


\bibitem[22]{22} Class Matcher. ORACLE. \emph{Java™ Platform Standard Ed. 8 Documentation} [online]. 2015 [cit. 2015-07-25]. Dostupné z: \verb|https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html|


\end{thebibliography}
\listoffigures
\listoftables
\end{document}